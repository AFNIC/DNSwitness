=head1 NAME

DNSdelve.Dnssec - a module for dnsdelve

=head1 SYNOPSIS

B<dnsdelve> [options] -m  Dnssec I<zone_file> [module_options]


=head1 DESCRIPTION

dnsdelve gathers information from the DNS. 
It loads a list of delegated zones (from file I<zone_file>,
which must be in RFC 1035 format) and queries them for various
records.

DNSdelve.Dnssec module checks each delegated zone of the zone file and interrogates the DNS asking for DNSKEY and NSEC (or NSEC3) records. 

If keys are found, they are stored in the database Key table. 

Meta-data concerning a run (timestamp, module, filename, total number of domain names, sampling rate) are stored in the Runs table.

Data concerning a single domain name ckecked are stored in the Tests table. The domain names are stored in the Zones table. 

=head1 OPTIONS

DNSdelve.Dnssec has the following options. They all have a short form (one
letter) and a longer form (prefixed by two dashes).

Remember that dnsdelve itself has options, too (see dnsdelve documentation).

=over 4

=item -n --num_tasks I<n>

The number of database writing threads. Default value is 1.

=item -b --database I<dbname>

The database in which results are to be stored. It can be just the name of a local database or a complete string connection.

=item -r --resolvers I<resolvers_list>

A comma-separated list of IP addresses of the resolver(s) to use. The default is the list indicated in /etc/resolv.conf.


=item -h --help

Prints a usage message.

=back



=head1 EXAMPLES 

=over 4 

=item A simple case 

dnsdelve -m Dnssec zone.db -b dnsdelve-dnssec -r 192.168.2.250, 192.168.2.251 

=item A more complex case 

dnsdelve -m Dnssec zone.db  -n 1 \ 

-b 'host=db.example.net dbname=dnsdelve-dnssec \ 

user=dnswitness  password=secret sslmode=require'

=back


=head1 FUNCTIONS 

DNSdelve.Dnssec module provides the following methods (which must be called in this order) :

=over 4

=item config(args, zonefile, sampling)

I<args> are the module arguments (see above). 
I<zonefile> is the name of the zone to be parsed. 
I<sampling> is the rate sampling.

This function parses the module option list. 



=item start(uuid, all_domains)

I<uuid> is a unique identifier. It is generated by the main program, it represents a unique id for each dnsdelve execution and it is stored in the measurements database.
I<all_domains>a list of domains from the parsed zone. This lists does not contain all the domains of the current zone but just a sample obtained using the sampling rate given. 

this function opens a connection to the database, writes some meta data about the current execution of the module (especially the uuid, the zone name parsed) and starts as many database writing threads as specified by the num_tasks option. 

It creates a stub resolver and starts as many database writing threads as required.

=item final 

This function stops all the writing threads.

=back 


=head1 OBJECTS

DNSdelve.Dnnsec module provides two object classes :  a Plugin class and a DnssecResult class. 

=over 4  

=item B<Plugin> 

This class inherits from the BasePlugin.Plugin class. It provides a method B<query> which receives a domain name and a list of DNS servers as arguments. Then it queries the DNS asking for the domain name DNSKEY and NSEC (or NSEC3) records. DNS requests go through the stub resolver created by the module. The result is stored in a DnssecResult object. During DNS interrogation, if an error happens the domain name is marked as broken.

Usage :
Plugin.query(domain_name, name_servers)

=item B<DnssecResult>

This class inherits from the BaseResult.Result class. It provides a method B<store> which will store the keys found details in the database Keys table.

Usage :
DnssecResult.store()

=back 




=head1 AUTHOR

Stephane Bortzmeyer <bortzmeyer@nic.fr>

=head1 SEE ALSO

=over 4  

=item B<dnsdelve> pod file

=item B<dnssec-create> sql file 

=item http://www.dnsdelve.net/

=back 

